<!-- Generated by SpecStory -->

# SQL Query Modification for Risk Assessment (2025-05-19 15:32:43)

_**User**_

@VidaCfFull.sql risk.dwd_risk_id_af_vida_di	credit_user_id	VidaCfFull	header_data	
risk.dwd_risk_id_af_vida_di	request_key	VidaCfFull	request_key	
risk.dwd_risk_id_af_vida_di	data_source_name	VidaCfFull	data_source_name	
risk.dwd_risk_id_af_vida_di	data_source_code	VidaCfFull	data_source_code	
risk.dwd_risk_id_af_vida_di	kyc_event_id	VidaCfFull	resp_raw_data	resp_raw_data.data.EventId
risk.dwd_risk_id_af_vida_di	kyc_status_raw	VidaCfFull	resp_raw_data	resp_raw_data.data.certificateIssued
risk.dwd_risk_id_af_vida_di	score_pob	VidaCfFull	resp_raw_data	"CASE 
  WHEN date(create_time) >= date('2024-03-21') THEN NULL
  ELSE if resp_raw_data.data.certificateIssued=200 then 10
elif resp_raw_data.data.certificateIssued=444 then 0
else Null
END"
risk.dwd_risk_id_af_vida_di	score_full_name	VidaCfFull	resp_raw_data	"if resp_raw_data.data.certificateIssued=200 then 10
elif resp_raw_data.data.certificateIssued=444 then 0
else Null"
risk.dwd_risk_id_af_vida_di	score_address	VidaCfFull		Null
risk.dwd_risk_id_af_vida_di	score_province	VidaCfFull		Null
risk.dwd_risk_id_af_vida_di	score_city	VidaCfFull		Null
risk.dwd_risk_id_af_vida_di	score_dob	VidaCfFull	resp_raw_data	"if resp_raw_data.data.certificateIssued=200 then 10
elif resp_raw_data.data.certificateIssued=444 then 0
else Null"
risk.dwd_risk_id_af_vida_di	score_district	VidaCfFull		Null
risk.dwd_risk_id_af_vida_di	score_village	VidaCfFull		Null
risk.dwd_risk_id_af_vida_di	score_nik	VidaCfFull	resp_raw_data	"if resp_raw_data.data.certificateIssued=200 then 10
elif resp_raw_data.data.certificateIssued=444 then 0
else Null"
risk.dwd_risk_id_af_vida_di	score_mother_maiden_name	VidaCfFull		Null
risk.dwd_risk_id_af_vida_di	score_family_card_no	VidaCfFull		Null
risk.dwd_risk_id_af_vida_di	score_demographic	VidaCfFull	resp_raw_data	"if resp_raw_data.data.certificateIssued=200 then 10
elif resp_raw_data.data.certificateIssued=444 then 0
else Null"
risk.dwd_risk_id_af_vida_di	score_selfiephoto	VidaCfFull	resp_raw_data	"if resp_raw_data.data.certificateIssued=200 then 10
elif resp_raw_data.data.certificateIssued=444 then 0
else Null"
risk.dwd_risk_id_af_vida_di	score_liveness	VidaCfFull	resp_raw_data	"返回：resp_raw_data.data.fields.score
条件 resp_raw_data.data.fields.field = 'score_liveness'"
risk.dwd_risk_id_af_vida_di	trace_id	VidaCfFull	trace_id	
risk.dwd_risk_id_af_vida_di	create_time	VidaCfFull	create_time	
risk.dwd_risk_id_af_vida_di	update_time	VidaCfFull	update_time	
risk.dwd_risk_id_af_vida_di	grass_date	VidaCfFull		根据这个逻辑改这个 sql

---

_**Assistant**_



---

我将根据您提供的映射关系修改SQL脚本，以处理VidaCfFull数据源。

---

```diff
- -- 将 ODS 表中的 VidaData 数据写入 DWD 表
+ -- 将 ODS 表中的 VidaCfFull 数据写入 DWD 表
  INSERT INTO TABLE risk.dwd_risk_id_af_vida_di
- WITH exploded_fields AS (
-   SELECT 
-     resp_raw_data,
-     header_data,
-     request_key,
-     data_source_name,
-     data_source_code,
-     trace_id,
-     create_time,
-     update_time,
-     field_obj.field AS field_name,
-     field_obj.score AS field_score
-   FROM risk.ods__credit_risk_datafetch_id_db__identity_data_tab__df
-   LATERAL VIEW EXPLODE(
-     FROM_JSON(
-       get_json_object(resp_raw_data, '$.data.fields'),
-       'array<struct<field:string,score:double>>'
-     )
-   ) fields AS field_obj
-   WHERE data_source_name IN ('VidaData', 'VidaCfFull', 'VidaLdnFull', 'VidaCfFr', 'VidaCfDemog', 'VidaCfFullNew', 'VidaCfFrNew', 'VidaCfDemogNew','VidaLdnFullNew') AND grass_date = '${ds}'
- )
  SELECT
    get_json_object(header_data, '$.CreditUserId') AS credit_user_id,
    request_key AS request_key,
    data_source_name AS data_source_name,
    data_source_code AS data_source_code,
-   get_json_object(resp_raw_data, '$.data.kycEventId') AS kyc_event_id,
-   get_json_object(resp_raw_data, '$.data.kyc_status_raw') AS kyc_status_raw,
-   -- 使用 MAX + CASE WHEN 来获取各个字段的 score
-   MAX(CASE WHEN field_name = 'pob' THEN field_score END) AS score_pob,
-   MAX(CASE WHEN field_name = 'full_name' THEN field_score END) AS score_full_name,
-   MAX(CASE WHEN field_name = 'address' THEN field_score END) AS score_address,
-   MAX(CASE WHEN field_name = 'province' THEN field_score END) AS score_province,
-   MAX(CASE WHEN field_name = 'city' THEN field_score END) AS score_city,
-   MAX(CASE WHEN field_name = 'dob' THEN field_score END) AS score_dob,
-   MAX(CASE WHEN field_name = 'district' THEN field_score END) AS score_district,
-   MAX(CASE WHEN field_name = 'village' THEN field_score END) AS score_village,
-   MAX(CASE WHEN field_name = 'nik' THEN field_score END) AS score_nik,
-   MAX(CASE WHEN field_name = 'mother_maiden_name' THEN field_score END) AS score_mother_maiden_name,
-   MAX(CASE WHEN field_name = 'family_card_no' THEN field_score END) AS score_family_card_no,
-   -- 计算平均分 (使用AVG函数直接计算)
-   AVG(field_score) AS score_demographic,
-   MAX(CASE WHEN field_name = 'selfiePhoto' THEN field_score END) AS score_selfiephoto,
-   MAX(CASE WHEN field_name = 'liveness' THEN field_score END) AS score_liveness,
+   get_json_object(resp_raw_data, '$.data.EventId') AS kyc_event_id,
+   get_json_object(resp_raw_data, '$.data.certificateIssued') AS kyc_status_raw,
+   -- 条件表达式处理字段
+   CASE 
+     WHEN TO_DATE(create_time) >= TO_DATE('2024-03-21') THEN NULL
+     ELSE 
+       CASE 
+         WHEN get_json_object(resp_raw_data, '$.data.certificateIssued') = '200' THEN 10
+         WHEN get_json_object(resp_raw_data, '$.data.certificateIssued') = '444' THEN 0
+         ELSE NULL
+       END
+   END AS score_pob,
+   CASE 
+     WHEN get_json_object(resp_raw_data, '$.data.certificateIssued') = '200' THEN 10
+     WHEN get_json_object(resp_raw_data, '$.data.certificateIssued') = '444' THEN 0
+     ELSE NULL
+   END AS score_full_name,
+   NULL AS score_address,
+   NULL AS score_province,
+   NULL AS score_city,
+   CASE 
+     WHEN get_json_object(resp_raw_data, '$.data.certificateIssued') = '200' THEN 10
+     WHEN get_json_object(resp_raw_data, '$.data.certificateIssued') = '444' THEN 0
+     ELSE NULL
+   END AS score_dob,
+   NULL AS score_district,
+   NULL AS score_village,
+   CASE 
+     WHEN get_json_object(resp_raw_data, '$.data.certificateIssued') = '200' THEN 10
+     WHEN get_json_object(resp_raw_data, '$.data.certificateIssued') = '444' THEN 0
+     ELSE NULL
+   END AS score_nik,
+   NULL AS score_mother_maiden_name,
+   NULL AS score_family_card_no,
+   CASE 
+     WHEN get_json_object(resp_raw_data, '$.data.certificateIssued') = '200' THEN 10
+     WHEN get_json_object(resp_raw_data, '$.data.certificateIssued') = '444' THEN 0
+     ELSE NULL
+   END AS score_demographic,
+   CASE 
+     WHEN get_json_object(resp_raw_data, '$.data.certificateIssued') = '200' THEN 10
+     WHEN get_json_object(resp_raw_data, '$.data.certificateIssued') = '444' THEN 0
+     ELSE NULL
+   END AS score_selfiephoto,
+   -- 处理score_liveness字段，需要从fields数组中获取
+   (
+     SELECT MAX(field_obj.score)
+     FROM (
+       SELECT EXPLODE(
+         FROM_JSON(
+           get_json_object(resp_raw_data, '$.data.fields'),
+           'array<struct<field:string,score:double>>'
+         )
+       ) AS field_obj
+     ) t
+     WHERE field_obj.field = 'score_liveness'
+   ) AS score_liveness,
    trace_id AS trace_id,
    create_time AS create_time,
    update_time AS update_time,
    '${ds}' AS grass_date
- FROM exploded_fields 
- WHERE data_source_name = 'VidaData'
- GROUP BY 
-   resp_raw_data,
-   header_data,
-   request_key,
-   data_source_name,
-   data_source_code,
-   trace_id,
-   create_time,
-   update_time
+ FROM risk.ods__credit_risk_datafetch_id_db__identity_data_tab__df
+ WHERE data_source_name = 'VidaCfFull' AND grass_date = '${ds}'
  ;
  
```

---

SQL脚本已经根据您提供的映射关系进行了修改。主要变化包括：

1. 更新了注释，指明处理VidaCfFull数据源
2. 移除了原先的WITH子句和EXPLODE操作，改为直接从表中查询
3. 根据映射规则更新了字段：
   - kyc_event_id来自resp_raw_data.data.EventId
   - kyc_status_raw来自resp_raw_data.data.certificateIssued
   - 为多个分数字段添加了条件逻辑，如certificateIssued=200时分数为10
   - score_pob增加了特殊条件：当create_time>=2024-03-21时为NULL
   - 设置不需要的字段为NULL
   - score_liveness使用子查询从fields数组中提取

4. 修改WHERE条件，只筛选VidaCfFull数据源
5. 移除了不必要的GROUP BY子句

有任何其他需要调整的地方，请告诉我。

---

_**User**_

我在想这种 json 解出来的应该不用考虑是 200 的 int 类型吧，即使是 int 是不是也可以兼容 string ‘200’ 呢？

---

_**Assistant**_



---

是的，您的理解是正确的。在Hive和Spark SQL中，`get_json_object`函数从JSON中提取的值都是以字符串(STRING)类型返回的，即使原始JSON中的值是数字类型。

关于兼容性:

1. 在SQL比较运算中，通常会进行隐式类型转换，所以比较:
   - `'200'` (字符串) = `200` (数字)
   - 在大多数SQL引擎中会返回`true`

2. 使用字符串比较(`'200'`)确实是更安全的做法，因为它匹配`get_json_object`的返回类型。

3. 如果想更明确地处理类型，也可以将提取的值转换为整数:
   ```sql
   WHEN CAST(get_json_object(resp_raw_data, '$.data.certificateIssued') AS INT) = 200 THEN 10
   ```

但就当前的SQL而言，使用字符串比较(`'200'`和`'444'`)是合适的，并且不太可能引起类型相关的问题。SQL引擎通常会处理这种情况下的类型转换。

---

_**User**_

java.sql.SQLException: java.util.concurrent.ExecutionException: java.lang.RuntimeException: org.apache.spark.sql.AnalysisException: Accessing outer query column is not allowed in:
Generate explode(from_json(ArrayType(StructType(StructField(field,StringType,true), StructField(score,DoubleType,true)),true), get_json_object(outer(resp_raw_data#287), $.data.fields), Some(Asia/Singapore))), false, [field_obj#304]
+- OneRowRelation

---

_**Assistant**_



---

这个错误表明在子查询中使用`EXPLODE`函数时无法访问外部查询的`resp_raw_data`列。这是Spark SQL的一个限制，在某些上下文中不允许引用外部查询的列。

我们需要修改SQL，使用`LATERAL VIEW EXPLODE`语法替代当前的子查询方法来处理`score_liveness`字段：

---



---



---

